import matplotlibmatplotlib.use('GTK')from matplotlib.matlab import *from scipy import *from scipy.stats import *from scipy.interpolate import *import randomfrom iolib import *from genlib import *from graphlib import *from modellib import *from statlib import *import BMEmatlabdef simucholcond(ch,ch0,zh0,covmodel,covparam,ns=1):    """        Translated by Dimitri D'Or - November 2004    Status: debugged, not tested        % simucholcond              - conditional simulation by the Cholesky method (Jan 1,2001)    %    % Generate conditional simulations using the Choleski    % decomposition method, as for simuchol.m. The conditioning    % values are zero mean Gaussian distributed hard data.    % Simulated values are Gaussian distributed.     %    % SYNTAX :    %    % [Zh,L]=simucholcond(ch,ch0,zh0,covmodel,covparam,ns);    %    % INPUT :    %    % ch         nh by d   matrix of coordinates for the locations    %                      where hard data have to be simulated. A    %                      line corresponds to the vector of coordinates    %                      at a simulation location, so the number of    %                      columns corresponds to the dimension of the    %                      space. There is no restriction on the dimension    %                      of the space.    % ch0        nh0 by d  matrix of coordinates for the hard conditioning    %                      values, with the same convention as for ch.    % zh0        nh0 by 1  vector of the hard conditioning values at the    %                      coordinates specified in ch0.    % covmodel   string    string that contains the name of the covariance    %                      model which is used for the simulation (see the    %                      MODELS directory). Variogram models are not    %                      available for this function.    % covparam   1 by k    vector of values for the parameters of covmodel,    %                      according to the convention for the corresponding    %                      covariance model.    % ns         scalar    number of sets of simulated values which are required.    %                      If the optional ns variable is omitted from the input    %                      list of variables, simuchol.m produces a single set    %                      of simulated values.    %     % OUTPUT :    %    % Zh         nh by ns  matrix of simulated Gaussian distributed hard values at    %                      the coordinates specified in ch. Each column corresponds    %                      to a different simulation, so that if ns=1 or if ns is    %                      omitted, Zh is a column vector of values. Each simulated    %                      vector of values is statistically independant from the    %                      others.    % L          n by n    upper triangular matrix obtained from the Choleski    %                      decomposition of the global covariance matrix C for    %                      values at the ch coordinates, such that C=L'*L.    %    % NOTE :    %    % 1- When using simucholcond.m, the hard data values should be    % zero mean Gaussian distributed. If this is not the case, the    % mean should be substracted from the zh0 values prior to the    % simulation, and appropriate transformations should be performed    % (see other2gauss.m).    %    % 2- All the specific conventions for specifying nested models,    % multivariate or space-time cases are the same as for kriging.m.    """    ## %%%%% Error message    index=isinstance(ch,list)          # % test if there is an index for the variables    if index:        nh=ch[0].shape[0]              # % nh is the number of simulation points        nindexh=len(ch[1])        if nindexh==1:            ch[1]=matrixmultiply(ch[1],ones((nh,1)))    index=findpairs(ch,ch0)    if prod(index.shape)!=0:  # ~isempty(index):        return 'ch and ch0 cannot contain identical coordinates'    ## %%%%% Use the conditional distributions    K11=coord2K(ch,ch,covmodel,covparam)    K22=coord2K(ch0,ch0,covmodel,covparam)    K12=coord2K(ch,ch0,covmodel,covparam)    invK22=inverse(K22)    K12invK22=matrixmultiply(K12,invK22)    K1if2=K11-matrixmultiply(K12invK22,transpose(K12))    m1if2=matrixmultiply(K12invK22,zh0)    L=linalg.cholesky(K1if2)    Lt=transpose(L)    n=Lt.shape[0]    Zh=zeros((n,ns))    for i in xrange(ns):        Zh[:,i]=matrixmultiply(Lt,randn(n,1))+m1if2    return Zh,Ldef simucholcondME(ch,ch0,cs0,zh0,zs0,vs0,covmodel,covparam,ns=1):    """        Translated by Dimitri D'Or - November 2004    Status: debugged, not tested        % simucholcondME            - conditional simulation by the Cholesky method with measurement errors (Jan 1,2001)    %    % Simulate values conditionally to both hard and soft data.    % The probabilistic soft data are assumed to be completely    % characterized by their mean and their variance (see    % krigingME.m for more information on the Mesurement Error    % concept).    %    % SYNTAX :    %    % [Zh,L]=simucholcondME(ch,ch0,cs0,zh0,zs0,vs0,covmodel,covparam,ns);    %    % INPUT :    %    % ch         nh by d   matrix of coordinates for the locations    %                      where hard data have to be simulated. A    %                      line corresponds to the vector of coordinates    %                       at a simulation location, so the number of    %                      columns corresponds to the dimension of the    %                      space. There is no restriction on the dimension    %                      of the space.    % ch0        nh0 by d  matrix of coordinates for the hard conditioning    %                      values, with the same convention as for ch.    % cs0        ns0 by d  matrix of coordinates for the soft conditioning    %                      values, with the same convention as for ch.    % zh0        nh0 by 1  vector of the hard conditioning values at the    %                      coordinates specified in ch0.    % zs0        ns0 by 1  vector of the values for the mean of the conditioning    %                      soft data at the coordinates specified in cs0.    % vs0        ns0 by 1  vector of values for the variance of the conditioning    %                      soft data at the coordinates specified in cs0.    % covmodel   string    string that contains the name of the covariance    %                      model which is used for the simulation (see the    %                      MODELS directory). Variogram models are not    %                      available for this function.    % covparam   1 by k    vector of values for the parameters of covmodel,    %                      according to the convention for the corresponding    %                      covariance model.    % ns         scalar    number of sets of simulated values which are required.    %                      If the optional ns variable is omitted from the input    %                      list of variables, a single set of simulated values is    %                      generated.    %     % OUTPUT :    %    % Zh         nh by ns  matrix of simulated Gaussian distributed hard values at    %                      the coordinates specified in ch. Each column corresponds    %                      to a different simulation, so that if ns=1 or if ns is    %                      omitted, Zh is a column vector of values. Each simulated    %                      vector of values is statistically independant from the    %                      others.    % L          nh by nh  upper triangular matrix obtained from the Choleski    %                      decomposition of the global covariance matrix C for    %                      values at the ch coordinates, such that C=L'*L.    %     % OUTPUT :    %    % Zh  n by ns matrix of conditionally simulated values    % L   n by n upper triangular matrix such that K=L'*L    %            is the covariance matrix    %    % NOTE :    %    % 1- When using simucholcondME.m, the hard and data values    % should be zero mean Gaussian distributed. If this is not    % the case, the mean should be substracted from the zh0 and    % zs0 values prior to the simulation, and appropriate    % transformations should be performed (see other2gauss.m).    %    % 2- Note that, as for krigingME.m, ch0 and zh0 can be entered    % as the empty [ ] matrices in the case there are no available    % hard data at all.    %    % 3- All the specific conventions for specifying nested models,    % multivariate or space-time cases are the same as for kriging.m.    """    ## %%%%% Error message    isarray=isinstance(ch,list)        # % test if there is an index for the variables    if isarray:        nh=ch[0].shape[0]              # % nh is the number of simulation points        nindexh=len(ch[1])        if nindexh==1:            ch[1]=matrixmultiply(ch[1],ones((nh,1)))    index=findpairs(ch,ch0)    if  prod(index.shape)!=0:  # ~isempty(index):        return 'ch and ch0 cannot contain identical coordinates'    ## %%%%% Use the conditional distributions    K11=coord2K(ch,ch,covmodel,covparam)    if isarray:        ch0s0=[concatenate((ch0[0],cs0[0])),concatenate((ch0[1],cs0[1]))]        K22=coord2K(ch0s0,ch0s0,covmodel,covparam)        K22=K22+diag(concatenate((zeros((ch[0].shape[0],1)),vs0)))        K12=coord2K(ch,ch0s0,covmodel,covparam)    else:        K22=coord2K(concatenate((ch0[0],cs0[0])),concatenate((ch0[0],cs0[0])),covmodel,covparam)        K22=K22+diag(concatenate((zeros((ch[0].shape[0],1)),vs0)))        K12=coord2K(ch,concatenate((ch0[0],cs0[0])),covmodel,covparam)            invK22=inverse(K22)    K12invK22=matrixmultiply(K12,invK22)    K1if2=K11-matrixmultiply(K12invK22,transpose(K12))    m1if2=matrixmultiply(K12invK22,concatenate((zh0,zs0)))    L=linalg.cholesky(K1if2)    Lt=transpose(L)    n=Lt.shape[0]    Zh=zeros((n,ns))    for i in xrange(ns):        Zh[:,i]=matrixmultiply(Lt,randn(n,1))+m1if2    return Zh,Ldef simuchol(ch,covmodel,covparam,ns=1):    """        Translated by Dimitri D'Or - December 2004    Status: debugged, not tested        % simuchol                  - simulation by the Cholesky method (Jan 1,2001)    %    % Implementation of the traditional non conditional    % simulation method based on a Choleski decomposition    % of the covariance matrix. This simulation method is    % especially recommended for simulating independantly    % several sets of a limited number of hard values    % (less than few hundreds). Simulated values are zero    % mean Gaussian distributed.     %    % SYNTAX :    %    % [Zh,L]=simuchol(ch,covmodel,covparam,ns);    %    % INPUT :    %    % ch         nh by d   matrix of coordinates for the locations    %                      where hard data have to be simulated. A    %                      line corresponds to the vector of coordinates    %                      at a simulation location, so the number of    %                      columns corresponds to the dimension of the    %                      space. There is no restriction on the dimension    %                      of the space.    % covmodel   string    string that contains the name of the covariance    %                      model which is used for the simulation (see the    %                      MODELS directory). Variogram models are not    %                      available for this function.    % covparam   1 by k    vector of values for the parameters of covmodel,    %                      according to the convention for the corresponding    %                      covariance model.    % ns         scalar    number of sets of simulated values which are required.    %                      If the optional ns variable is omitted from the input    %                      list of variables, simuchol.m produces a single set    %                      of simulated values.    %     % OUTPUT :    %    % Zh         nh by ns  matrix of zero mean simulated Gaussian distributed hard    %                      values at the coordinates specified in ch. Each column    %                      corresponds to a different simulation, so that if ns=1    %                      or if ns is omitted, Zh is a column vector of values.    %                      Each simulated vector of values is statistically    %                      independant from the others.    % L          nh by nh  upper triangular matrix obtained from the Choleski    %                      decomposition of the global covariance matrix C for    %                      values at the ch coordinates, such that C=L'*L.    %    % NOTE :    %    % All the specific conventions for specifying nested models,    % multivariate or space-time cases are the same as for kriging.m.    """    K=coord2K(ch,ch,covmodel,covparam)    L=linalg.cholesky(K)    Lt=transpose(L)    n=Lt.shape[0]    Zh=zeros((n,ns))    for i in xrange(ns):       Zh[:,i]=matrixmultiply(Lt,randn(n,1))    return Zh,Ldef simuinterval(Zs,I,Vmethod,Vvalue):    """        Translated by Dimitri D'Or - December 2004    Status: debugged, not tested    % simuinterval              - Simulate soft interval data (Jan 1,2000)    %     % Simulate the lower and upper bounds of soft interval data using    % a set of known Z values at the soft data points    %    % SYNTAX :    %    % [a,b]=simuinterval(Zs,I,Vmethod,Vvalue)    %    % INPUT :    %    % Zs         nh by nSim   matrix of Z values at the soft data points    % I          vector       value(s) for the interval length    % Vmethod    integer      integer between 0 and 3 indicating the method    %                         used to generate intervals as follow    %    Vmethod=0, 1 or 2: I is a scalar, a=Zs+V-I/2, b=Zs+V+I/2    %      Vmethod=0: V=0    %      Vmethod=1: V is uniformly distributed between -I/2 and I/2    %      Vmethod=2: V=Vvalue    %    Vmethod=3: I is a vector of increasing values I(i), a=I(i)<Zs<b=I(i+1)     %    % OUTPUT :    %    % a          ns by nSim   vector of values for the lower bound of the intervals    % b          ns by nSim   vector of values for the upper bound of the intervals    %                         a and b are such that a<=Zh<=b    """    if len(Zs.shape)==1:        Zs=Zs[:,NewAxis]        [ns,nSim]=Zs.shape    if Vmethod==0:        V=0    elif Vmethod==1:        V=(rand(ns,nSim)-0.5)*I    elif Vmethod==2:        if (Vvalue<-I/2) or (Vvalue>I/2):            return 'Vvalue must be in interval [-I/2,I/2]'        V=Vvalue    elif Vmethod==3:        mInf=-5        pInf=5        ZkGrid=I        ZkGridInf=concatenate((mInf,ZkGrid,pInf))        for iSim in xrange(nSim):            for i in xrange(ns):                ia=sum(ZkGrid<Zs[i,iSim])                a[i,iSim]=ZkGridInf[ia+1]                b[i,iSim]=ZkGridInf[ia+2]    else:      return 'Vmethod=%n is not a valid option ' %Vmethod    if (Vmethod==0) or (Vmethod==1) or (Vmethod==2):        a=Zs+V-I/2        b=Zs+V+I/2    return (a,b)def simuprobabilistic(Zs,softpdftype,NV,WidthV,probdensV):    """        Translated by Dimitri D'Or - December 2004    Status: debugged, not tested    % simuprobabilistic         - simulate probabilistic data (Jan 1,2000)    %    % Given a set of hard data Zs and a template for the ns-dimensional    % pdf fs, provides the actual ns-dimensional pdf fs (i.e. the soft     % probabilistic data) at the soft data points    %     % SYNTAX :    %    % [nl,limi,probdens]=simuprobabilistic(Zs,softpdftype,NV,WidthV,probdensV);    %    % INPUT :    %    % Zs         ns by nSim   matrix of simulated hard data     %softpdftype scalar       type of the ns-dimensional pdf fs:     %                           1-Histogram, 2-Linear, 3-Grid Histogram,     %                           4-Grid Linear (see helpsoftpdftype)    % NV         ns by 1      number of intervals in each dimension    % WidthV     matrix       interval widths    %                         If softpdftype=1 or 2, WidthV is a ns by     %                           max(NV) matrix of interval widths.     %                         If softpdftype=3 or 4 WidthV is a ns by 1 vector    %                           with the constant interval width for each dim.    % probdensV  matrix       values of fs along each dimension     %                         If softpdftype=1 or 3 probdensV is a ns by max(NV)      %                            matrix of fs value for the intervals along each dim.    %                         If softpdftype=2 or 4 probdensV is a ns by max(NV)+1    %                            matrix of fs value for the interval limits along    %                            each dimension    %    % OUTPUT :    %    % nl         ns by 1      nl=NV+1    % limi       array        limits of intervals for which the soft pdf is    %                         specified (see helpsoftpdftype)    %                         If softpdftype=1 or 2, limi is a ns by max(nl)      %                           by nSim array of interval limits     %                         If softpdftype=3 or 4 limi is a ns by 3 by nSim    %                           array with the lower limits, increment and upper     %                           limit of intervals    % probdens   array        value of the soft pdf (probability density values)    %                           at the intervals limits given by limi    %                         If softpdftype=1 or 3, probdens is a ns by      %                           max(nl)-1 by nSim array of interval probabilities    %                         If softpdftype=2 or 4 probdens is a ns by max(nl)     %                           by nSim array of proba value at the interval limits.    """    ## %    ## %Check inputs    ## %    if len(Zs.shape)==1:        Zs=Zs[:,NewAxis]        [ns,nSim]=Zs.shape    if (ns<1):        return 'must have at least one soft data point'    if (nSim<1):        return 'must generate at one least simulation'    if NV.shape[0]!=ns:        return 'NV must be a vector of length ns'    NVmax=max(NV)    ## %    ## %  Check size of WidthV    ## %    if (softpdftype==1) or (softpdftype==2):        if (WidthV.shape[0]!=ns) or (WidthV.shape[1]!=NVmax):            return 'WidthV must be a ns by max(NV) matrix'    elif (softpdftype==3) or (softpdftype==4):        if (WidthV.shape[0]!=ns) or (WidthV.shape[1]!=1):            return 'WidthV must be a ns by 1 matrix'    else:        return 'Unacceptable value for softpdftype'    ## %    ## % Check size of probdensV    ## %    if (softpdftype==1) or (softpdftype==3):        if (probdensV.shape[0]!=ns) or (probdensV.shape[1]!=NVmax):            return 'probdensV must be a ns by max(NV) matrix'    elif (softpdftype==2) or (softpdftype==4):        if (probdensV.shape[0]!=ns) | (probdensV.shape[1]!=NVmax+1):            return 'probdensV must be a ns by max(NV)+1 matrix'    nl=NV+1    ## %    ## % Calculate limiV, the limits of the intervals for V starting at 0    ## % and UV, the limits of intervals for the uniformly distributed U    ## %    ## %    ## % Do histogram case first    ## %    if (softpdftype==1) or (softpdftype==3):        if (softpdftype==3):            WidthV=BMEmatlab.kron(WidthV,ones((1,max(NV))))        for ist in xrange(ns):            limiV[ist,0]=0            UV[ist,0]=0            for iv in xrange(1,nl[ist]):                limiV[ist,iv]=limiV[ist,iv-1]+WidthV[ist,iv-1]                UV[ist,iv]=UV[ist,iv-1]+WidthV[ist,iv-1]*probdensV[ist,iv-1]        ## %        ## %  Check that WidthV and probdensV are properly normalized        ## %        Eps=1e-10        for ist in xrange(ns):            if (UV[ist,nl[ist]]<1.0-Eps) or (UV[ist,nl[ist]]>1.0+Eps):                return 'WidthV and probdensV not normalized probability'        ## %        ## %  Generate U uniformly between 0 and 1        ## %  then transform U to V so that V has a distribution described        ## %  by WidthV and probdensV        ## %        U=rand(ns,nSim)        for ist in xrange(ns):            UVgrid=UV[ist,:nl[ist]];            for iSim in xrange(nSim):                iv=sum(UVgrid<U[ist,iSim])                V[ist,iSim]=limiV[ist,iv]+(U[ist,iSim]-UVgrid[iv])/probdensV[ist,iv]        Y=Zs-V        if (softpdftype==1):            limi=zeros((ns,max(nl),nSim))*NaN            for ist in xrange(ns):                for iv in xrange(nl[ist]):                    limi[ist,iv,:]=Y[ist,:]+limiV[ist,iv]        elif (softpdftype==3):            limi=zeros((ns,3,nSim))*NaN            for ist in xrange(ns):                limi[ist,0,:]=Y[ist,:]                limi[ist,1,:]=WidthV[ist,0]                limi[ist,2,:]=Y[ist,:]+NV[ist]*WidthV[ist,0]+Eps        probdens=zeros((ns,max(nl)-1,nSim))*NaN        for ist in xrange(ns):            for iv in xrange(NV[ist]):                probdens[ist,iv,:]=probdensV[ist,iv]                    elif (softpdftype==2) or (softpdftype==4):        if (softpdftype==4):            WidthV=BMEmatlab.kron(WidthV,ones((1,max(NV))))        for ist in xrange(ns):            limiV[ist,0]=0            UV[ist,0]=0            for iv in xrange(1,nl[ist]):                limiV[ist,iv]=limiV[ist,iv-1]+WidthV[ist,iv-1]                UV[ist,iv]=UV[ist,iv-1]+WidthV[ist,iv-1]*0.5*(probdensV[ist,iv-1]+probdensV[ist,iv])        ## %        ## %  Check that WidthV and probdensV are properly normalized        ## %        Eps=1e-10        for ist in xrange(ns):            if (UV[ist,nl[ist]]<1.0-Eps) or (UV[ist,nl[ist]]>1.0+Eps):                return 'WidthV and probdensV not normalized probability'        ## %        ## %  Generate U uniformly between 0 and 1        ## %  then transform U to V so that V has a distribution described        ## %  by WidthV and probdensV        ## %        U=rand(ns,nSim)        for ist in xrange(ns):            UVgrid=UV[ist,:nl[ist]]            for iSim in xrange(nSim):                iv=sum(UVgrid<U[ist,iSim])                fsp=(probdensV[ist,iv+1]-probdensV[ist,iv])/(limiV[ist,iv+1]-limiV[ist,iv])                if (fsp!=0):                    fso=probdensV[ist,iv]-limiV[ist,iv]*fsp                    V[ist,iSim]=1/fsp*(-fso+sqrt(probdensV[ist,iv]**2+2*fsp*(U[ist,iSim]-UVgrid[iv])))                elif (probdensV[ist,iv]!=0):                    V[ist,iSim]=limiV[ist,iv]+(U[ist,iSim]-UVgrid[iv])/probdensV[ist,iv]                else:                    V[ist,iSim]=limiV[ist,iv]        Y=Zs-V        if (softpdftype==2):            limi=zeros((ns,max[nl],nSim))*NaN            for ist in xrange(ns):                for iv in xrange(nl[ist]):                    limi[ist,iv,:]=Y[ist,:]+limiV[ist,iv]        elif(softpdftype==4):            limi=zeros((ns,3,nSim))*NaN            for ist in xrange(ns):                limi[ist,0,:]=Y[ist,:]                limi[ist,1,:]=WidthV[ist,0]                limi[ist,2,:]=Y[ist,:]+NV[ist]*WidthV[ist,0]+Eps        probdens=zeros((ns,max[nl],nSim))*NaN        for ist in xrange(ns):            for iv in xrange(nl[ist]):                probdens[ist,iv,:]=probdensV[ist,iv]    return nl,limi,probdensdef simuseqcondInt(ch,ch0,cs0,zh0,a0,b0,covmodel,covparam,nhmax,nsmax,dmax,order,*options):    """        Translated by Dimitri D'Or - December 2004    Status: debugged, not tested    % simuseqcondInt            - conditional simulation by sequential method with interval data (Jan 1,2001)    %    % Conditional simulation of a set of random variables    % at a set of cartesian coordinates using a sequential    % method. There are hard and interval conditioning data    %    % SYNTAX :    %    % [zh]=simuseqcondInt(ch,ch0,cs0,zh0,a0,b0,covmodel,covparam,nhmax,nsmax,dmax,order,options);    %    % INPUT :    %    % ch         nh by d   matrix of coordinates for the locations    %                      where hard data have to be simulated. A    %                      line corresponds to the vector of coordinates    %                      at a simulation location, so the number of    %                      columns corresponds to the dimension of the    %                      space. There is no restriction on the dimension    %                      of the space.    % ch0        nh0 by d  matrix of coordinates for the hard conditioning    %                      values, with the same convention as for ch.    % cs0        ns0 by d  matrix of coordinates for the soft conditioning    %                      values, with the same convention as for ch.    % zh0        nh0 by 1  vector of the hard conditioning values at the    %                      coordinates specified in ch0.    % a0         ns0 by 1  vector of values for the lower bound of the intervals    %                      at the coordinates specified in cs0.    % b0         ns0 by 1  vector of values for the upper bound of the intervals    %                      at the coordinates specified in cs0.    % covmodel   string    string that contains the name of the covariance    %                      model which is used for the simulation (see the    %                      MODELS directory). Variogram models are not    %                      available for this function.    % covparam   1 by k    vector of values for the parameters of covmodel,    %                      according to the convention for the corresponding    %                      covariance model.    % nhmax      scalar    maximum number of conditioning or previously    %                      simulated hard data values that are considered for    %                      the simulation at each new location in the sequence.    % nsmax      scalar    maximum number of conditionin soft data that are    %                      considered for the simulation at each new location in    %                      the sequence.     % dmax       scalar    maximum distance between a simulation location and    %                      conditioning or previously visited simulation locations.    %                      All locations separated by a distance smaller than dmax    %                      from a simulation location will be included in the    %                      simulation process for that location, whereas other    %                      locations are neglected. When there are no locations    %                      in the local neighbourhood, dmax is repeatidly increased    %                      until there is at least one value in the neighbourhood.    % order      scalar    order of the polynomial mean along the spatial axes at    %                      the simulation locations. For the zero-mean case, NaN    %                      (Not-a-Number) is used. Note that order=NaN can only be    %                      used with covariance models and not with variogram models.    % options    1 by 4    vector of optional parameters that can be used if default    %                      values are not satisfactory (otherwise this vector can    %                      simply be omitted from the input list of variables), where :    %                      options(1)=1 for displaying the simulation location currently    %                      processed (default value is 0),    %                      options(2)=1 for a random selection of the visited simulation    %                      locations during the sequential process (default value is 1),    %                      options(3) specifies the maximum number of evaluation that    %                      can be done by the FORTRAN77 subroutines for the integrals    %                      (default value is 50 000. This value should be increased if a    %                      warning message appears on the screen during the computation),    %                      options(4) specifies the maximum admissible relative error on    %                      the estimation of these integrals (default value is 1e-4).    %    % OUTPUT :    %    % z          nh by 1   vector of simulated hard values at the coordinates specified in    %                      ch. Depending on the choice of order, the values are not    %                      necessarily zero mean distributed.    %    % NOTE :    %    % 1- Note that in the case there are no available hard data at all,    % ch0 and zh0 can be entered as the empty [ ] matrices.    %    % 2- All the specific conventions for specifying nested models,    % multivariate or space-time cases are the same as for kriging.m.    """    ## %%%% function yi=interp1monotone(x,y,xi)    ## %    ## % A modified interp1 function that works if y is non strictly monotonic     ## %    def interp1monotone(x,y,xi):        idx=find(xi==x)        if len(idx)!=0:            yi=min(take(y,idx))        else:            i1=max(find(x<xi))            i2=min(find(x>xi))            x1=x[i1]            x2=x[i2]            y1=y[i1]            y2=y[i2]            yi=y1+(y2-y1)*(xi-x1)/(x2-x1)        return yi    ## %%%%% Error message    index=isinstance(ch,list)          # % test if there is an index for the variables    if index==1:        nh=ch[0].shape[0]              # % nh is the number of simulation points        nindexh=len(ch[1])        if nindexh==1:            ch[1]=ch[1]*ones(nh,1)    index=findpairs(ch,ch0)    if len(index)!=0:        return 'ch and ch0 cannot contain identical coordinates'    ## %%%%% Initialize the parameters    if not options:        options[0]=0        options[1]=1        options[2]=50000        options[3]=1e-4    isarray=isinstance(ch,list)    if not isarray:        nh=ch.shape[0]        nh0=ch0.shape[0]    else:        nh=len(ch[1])        nh0=len(ch0[1])    if options[1]==1:        index=random.shuffle(nh)    # Performs random permutation        if not isarray:            ch=take(ch,index)        else:            ch[0]=take(ch[0],index)            ch[1]=take(ch[1],index)    chtemp=ch0    zhtemp=zh0    zs0=(b0+a0)/2    vs0=((b0-a0)**2)/12    for i in xrange(nh):        if not isarray:            ck=ch[i,:]        else:            ck=[ch[0][i,:],ch[1][i]]        zk=NaN        dmaxiter=0        while isnan(zk):            dmaxiter=dmaxiter+dmax            [zk,vk]=krigingME(ck,chtemp,cs0,zhtemp,zs0,vs0,covmodel,covparam,nhmax,nsmax,dmaxiter,order)        zfile=matrixmultiply(transpose(arrayrange(-4,4,0.1),sqrt(vk)))+zk        [zhest,pdfest,info]=BMEintervalPdf(zfile,ck,chtemp,cs0,zhtemp,a0,b0,covmodel,covparam,nhmax,nsmax,dmaxiter,order,options)        cdfest=pdf2cdf(zhest,pdfest)        p=rand(1)*(max(cdfest)-min(cdfest))+min(cdfest)        zhtemp[i+nh0,0]=interp1monotone(cdfest,zhest,p)        if not isarray:            chtemp[i+nh0,:]=ck        else:            chtemp[0][i+nh0,:]=ck[0]            chtemp[1][i+nh0,0]=ck[1]        if options[0]==1:            print i,'/',nh    zh=zhtemp[nh0:nh+nh0]    if options[1]==1:        index=argsort(index)        zh=take(zh,index)    return zhdef simuseqcond(ch,ch0,zh0,model,param,nhmax,dmax,order,*options):    """        Translated by Dimitri D'Or - December 2004    Status: debugged, not tested    % simuseqcond               - conditional simulation by sequential method (Jan 1,2001)    %    % Generate conditional simulations using the sequential    % simulation method, where the conditioning values are    % hard data. The simuseqcond.m function is based on the    % use of the kriging.m function. To the opposite of the    % simuseq.m function, this function allows the user to    % use both variogram and covariance models. It is also    % possible to specify the order of a polynomial mean, so    % hard data do not have to be necessarily zero mean    % distributed. Simulated values are Gaussian distributed.     %    % SYNTAX :    %    % [zh]=simuseqcond(ch,ch0,zh0,model,param,nhmax,dmax,order,options);    %    % INPUT :    %    % ch         nh by d   matrix of coordinates for the locations    %                      where hard data have to be simulated. A    %                      line corresponds to the vector of coordinates    %                      at a simulation location, so the number of    %                      columns corresponds to the dimension of the    %                      space. There is no restriction on the dimension    %                      of the space.    % ch0        nh0 by d  matrix of coordinates for the hard conditioning    %                      values, with the same convention as for ch.    % zh0        nh0 by 1  vector of the hard conditioning values at the    %                      coordinates specified in ch0.    % model      string    that contains the name of the variogram or the     %                      covariance model which is used for the simulation    %                      (see the MODELS directory).    % param      1 by k    vector of values for the parameters of model,    %                      according to the convention for the corresponding    %                      variogram or covariance model.    % nhmax      scalar    maximum number of previously simulated hard data    %                      values that are considered for the simulation at    %                      each new location in the sequence.     % dmax       scalar    maximum distance between a simulation location and    %                      conditioning or previously visited simulation locations.    %                      All locations separated by a distance smaller than dmax    %                      from a simulation location will be included in the    %                      simulation process for that location, whereas other    %                      locations are neglected. When there are no locations    %                      in the local neighbourhood, dmax is repeatidly increased    %                      until there is at least one value in the neighbourhood.    % order      scalar    order of the polynomial mean along the spatial axes at    %                      the simulation locations. For the zero-mean case, NaN    %                      (Not-a-Number) is used. Note that order=NaN can only be    %                      used with covariance models and not with variogram models.    % options    1 by 2    vector of optional parameters that can be used if default    %                      values are not satisfactory (otherwise this vector can    %                      simply be omitted from the input list of variables), where :    %                      options(1)=1 for displaying the simulation location    %                      currently processed (default value is 0),    %                      options(2)=1 for a random selection of the visited simulation    %                      locations in the sequence (default value is 1).    %    % OUTPUT :    %    % zh         nh by 1   vector of simulated Gaussian distributed hard values at the    %                      coordinates specified in ch. Depending on the choice of    %                      order, the values are not necessarily zero mean distributed.    %    % NOTE :    %    % All the specific conventions for specifying nested models, multivariate    % or space-time cases are the same as for kriging.m.    """    ## %%%%% Error message    index=isinstance(ch,list)          # % test if there is an index for the variables    if index==1:        nh=ch[0].shape[0]              # % nh is the number of simulation points        nindexh=len(ch[1])        if nindexh==1:            ch[1]=ch[1]*ones(nh,1)    index=findpairs(ch,ch0)    if len(index)!=0:        return 'ch and ch0 cannot contain identical coordinates'    ## %%%%% Initialize the parameters    if not options:        options[0]=0        options[1]=1    isarray=isinstance(ch,list)    if not isarray:        nh=ch.shape[0]        nh0=ch0.shape[0]    else:        nh=len(ch[1])        nh0=len(ch0[1])    if options[1]==1:        index=random.shuffle(nh)     # Performs random permutation        if not isarray:            ch=take(ch,index)        else:            ch[0]=take(ch[0],index)            ch[1]=take(ch[1],index)    chtemp=ch0    zhtemp=zh0    for i in xrange(nh):        if not isarray:            ck=ch[i,:]        else:            ck=[ch[0][i,:],ch[1][i]]        zk=NaN        dmaxiter=0        while isnan(zk):            dmaxiter=dmaxiter+dmax            [zk,vk]=kriging(ck,chtemp,zhtemp,model,param,nhmax,dmaxiter,order)        zhtemp[i+nh0,0]=randn(1)*sqrt(vk)+zk        if not isarray:            chtemp[i+nh0,:]=ck        else:            chtemp[0][i+nh0,:]=ck[0]            chtemp[1][i+nh0,0]=ck[1]        if options[0]==1:            print i,'/',nh    zh=zhtemp[nh0:nh+nh0]    if options[1]==1:        index=argsort(index)        zh=take(zh,index)    return zhdef simuseqcondME(ch,ch0,cs0,zh0,zs0,vs0,covmodel,covparam,nhmax,nsmax,dmax,order,*options):    """        Translated by Dimitri D'Or - December 2004    Status: debugged, not tested    % simuseqcondME             - conditional simulation by sequential method with measurement errors (Jan 1,2001)    %    % Simulate hard values conditionally to both hard and soft data,    % where the probabilistic soft data are assumed to be completely    % characterized by their mean and their variance. The simuseqcondME.m    % function is based on the use of the krigingME.m function.    % Simulated values are Gaussian distributed.    %    % SYNTAX :    %    % [zh]=simuseqcondME(ch,ch0,cs0,zh0,zs0,vs0,covmodel,covparam,nhmax,nsmax,dmax,order,options);    %    % INPUT :    %    % ch         nh by d   matrix of coordinates for the locations    %                      where hard data have to be simulated. A    %                      line corresponds to the vector of coordinates    %                      at a simulation location, so the number of    %                      columns corresponds to the dimension of the    %                      space. There is no restriction on the dimension    %                      of the space.    % ch0        nh0 by d  matrix of coordinates for the hard conditioning    %                      values, with the same convention as for ch.    % cs0        ns0 by d  matrix of coordinates for the soft conditioning    %                      values, with the same convention as for ch.    % zh0        nh0 by 1  vector of the hard conditioning values at the    %                      coordinates specified in ch0.    % zs0        ns0 by 1  vector of the values for the mean of the conditioning    %                      soft data at the coordinates specified in cs0.    % vs0        ns0 by 1  vector of values for the variance of the conditioning    %                      soft data at the coordinates specified in cs0.    % covmodel   string    string that contains the name of the covariance    %                      model which is used for the simulation (see the    %                      MODELS directory). Variogram models are not    %                      available for this function.    % covparam   1 by k    vector of values for the parameters of covmodel,    %                      according to the convention for the corresponding    %                      covariance model.    % nhmax      scalar    maximum number of conditioning or previously    %                      simulated hard data values that are considered for    %                      the simulation at each new location in the sequence.    % nsmax      scalar    maximum number of conditionin soft data that are    %                      considered for the simulation at each new location in    %                      the sequence.     % dmax       scalar    maximum distance between a simulation location and    %                      conditioning or previously visited simulation locations.    %                      All locations separated by a distance smaller than dmax    %                      from a simulation location will be included in the    %                      simulation process for that location, whereas other    %                      locations are neglected. When there are no locations    %                      in the local neighbourhood, dmax is repeatidly increased    %                      until there is at least one value in the neighbourhood.    % order      scalar    order of the polynomial mean along the spatial axes at    %                      the simulation locations. For the zero-mean case, NaN    %                      (Not-a-Number) is used. Note that order=NaN can only be    %                      used with covariance models and not with variogram models.    % options    1 by 2    vector of optional parameters that can be used if default    %                      values are not satisfactory (otherwise this vector can    %                      simply be omitted from the input list of variables), where :    %                      options(1)=1 for displaying the simulation location    %                      currently processed (default value is 0),    %                      options(2)=1 for a random selection of the visited simulation    %                      locations in the sequence (default value is 1).    %    % OUTPUT :    %    % zh         nh by 1   vector of simulated Gaussian distributed hard values at the    %                      coordinates specified in ch. Depending on the choice of    %                      order, the values are not necessarily zero mean distributed.    %    % NOTE :    %    % 1- Note that, as for krigingME.m, ch0 and zh0 can be entered    % as the empty [ ] matrices in the case there are no available    % hard data at all.    %    % 2- All the specific conventions for specifying nested models,    % multivariate or space-time cases are the same as for kriging.m.    """    ## %%%%% Error message    index=isinstance(ch,list)          # % test if there is an index for the variables    if index==1:        nh=ch[0].shape[0]              # % nh is the number of simulation points        nindexh=len(ch[1])        if nindexh==1:            ch[1]=ch[1]*ones(nh,1)    index=findpairs(ch,ch0)    if len(index)!=0:        return 'ch and ch0 cannot contain identical coordinates'    ## %%%%% Initialize the parameters    if not options:        options[0]=0        options[1]=1    isarray=isinstance(ch,list)    if not isarray:        nh=ch.shape[0]        nh0=ch0.shape[0]    else:        nh=len(ch[1])        nh0=len(ch0[1])    if options[1]==1:        index=random.shuffle(nh)     # Performs random permutation        if not isarray:            ch=take(ch,index)        else:            ch[0]=take(ch[0],index)            ch[1]=take(ch[1],index)    chtemp=ch0    zhtemp=zh0    for i in xrange(nh):        if not isarray:            ck=ch[i,:]        else:            ck=[ch[0][i,:],ch[1][i]]        zk=NaN        dmaxiter=0        while isnan(zk):            dmaxiter=dmaxiter+dmax            [zk,vk]=krigingME(ck,chtemp,cs0,zhtemp,zs0,vs0,covmodel,covparam,nhmax,nsmax,dmaxiter,order)        zhtemp[i+nh0,0]=randn(1)*sqrt(vk)+zk        if not isarray:            chtemp[i+nh0,:]=ck        else:            chtemp[0][i+nh0,:]=ck[0]            chtemp[1][i+nh0,0]=ck[1]        if options[0]==1:            print i,'/',nh    zh=zhtemp[nh0:nh+nh0]    if options[1]==1:        index=argsort(index)        zh=take(zh,index)    return zhdef simuseq(ch,covmodel,covparam,nhmax,dmax,*options):    """        Translated by Dimitri D'Or - December 2004    Status: debugged, not tested    % simuseq                   - simulation by sequential method (Jan 1,2001)    %    % Implementation of the sequential non conditional simulation    % method based on the iterated use of conditional distributions,    % so that values are simulated one by one. This simulation method    % is especially recommended for simulating few sets of numerous    % hard values (above few hundreds), as it does not require the    % storage of a global covariance matrix into memory. The simuseq.m    % function is based on the use of the kriging.m function. As for    % simuchol.m, simulated values are zero mean Gaussian distributed.    %    % SYNTAX :    %    % [zh]=simuseq(ch,covmodel,covparam,nhmax,dmax,options);    %    % INPUT :    %    % ch         nh by d   matrix of coordinates for the locations    %                      where hard data have to be simulated. A    %                      line corresponds to the vector of coordinates    %                      at a simulation location, so the number of    %                      columns corresponds to the dimension of the    %                      space. There is no restriction on the dimension    %                      of the space.    % covmodel   string    string that contains the name of the covariance    %                      model which is used for the simulation (see the    %                      MODELS directory). Variogram models are not    %                      available for this function.    % covparam   1 by k    vector of values for the parameters of covmodel,    %                      according to the convention for the corresponding    %                      covariance model.    % nhmax      scalar    maximum number of previously simulated hard data    %                      values that are considered for the simulation at    %                      each new location in the sequence.     % dmax       scalar    maximum distance between a simulation location and    %                      previously visited simulation locations. All locations    %                      separated by a distance smaller than dmax from a    %                      simulation location will be included in the simulation    %                      process for that location, whereas other locations are    %                      neglected. When there are no available previously    %                      visited simulation locations in the local neighbourhood    %                      (this is likely at the beginning of the simulation),    %                      dmax is repeatidly increased until there is at least    %                      one value in the neighbourhood.    % options    1 by 2    vector of optional parameters that can be used if default    %                      values are not satisfactory (otherwise this vector can    %                      simply be omitted from the input list of variables), where :    %                      options(1)=1 for displaying the simulation location    %                      currently processed (default value is 0),    %                      options(2)=1 for a random selection of the visited simulation    %                      locations in the sequence (default value is 1).    %    % OUTPUT :    %    % zh         nh by 1   vector of zero mean simulated Gaussian distributed hard    %                      values at the coordinates specified in ch.    %    % NOTE :    %    % All the specific conventions for specifying nested models, multivariate    % or space-time cases are the same as for kriging.m.    """    if not options:        options[0]=0;        options[1]=1    isarray=isinstance(ch,list)    if not isarray:        nh=ch.shape[0]    else:        nh=len(ch[1])    if options[1]==1:        index=random.shuffle(nh)    # Performs random permutation        if not isarray:            ch=take(ch,index)        else:            ch[0]=take(ch[0],index)            ch[1]=take(ch[1],index)    if not isarray:        chtemp[0,:]=ch[0,:]    else:        chtemp[0][0,:]=ch[0][0,:]        chtemp[1][0]=ch[1][0]    vk=coord2K(chtemp,chtemp,covmodel,covparam)    zhtemp[0]=randn(1)*sqrt(vk)    order=NaN    for i in xrange(1,nh):        if not isarray:            ck=ch[i,:]        else:            ck=[ch[0][i,:],ch[1][i]]        zk=NaN        dmaxiter=0        while isnan(zk):            dmaxiter=dmaxiter+dmax            [zk,vk]=kriging(ck,chtemp,zhtemp,covmodel,covparam,nhmax,dmaxiter,order)        zhtemp[i,0]=randn(1)*sqrt(vk)+zk        if ~isarray:            chtemp[i,:]=ck        else:            chtemp[0][i,:]=ck[0]            chtemp[1][i,0]=ck[1]        if options[0]==1:            print i,'/',nh    zh=zhtemp    if options[1]==1:        index=argsort(index)        zh=take(zh,index)    return zh